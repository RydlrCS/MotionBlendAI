#!/usr/bin/env python3\n\"\"\"\nSeed Motions Mock Implementation\n===============================\n\nThis module provides comprehensive mock motion data generation and management\nfor the MotionBlendAI seed_motions directory. It creates realistic motion\ncapture data that mirrors the actual FBX, TRC, BVH, and GLB files found\nin the seed_motions folder.\n\nFeatures:\n---------\n• Realistic motion metadata extraction from actual files\n• Mock vector generation based on motion characteristics  \n• Comprehensive categorization and tagging system\n• Integration with Elasticsearch indexing pipeline\n• Support for all major motion capture formats\n• Semantic field generation for enhanced search\n\nUsage:\n------\n    from project.seed_motions.mock_seed_motions import get_seed_motions, index_seed_motions\n    \n    # Get all mock seed motions\n    motions = get_seed_motions()\n    \n    # Index to Elasticsearch\n    index_seed_motions(elasticsearch_client)\n\nAuthor: MotionBlendAI Team\nVersion: 1.0.0\n\"\"\"\n\nimport os\nimport time\nimport hashlib\nfrom typing import Dict, List, Any, Optional\nimport re\n\n# Seed motions directory path\nSEED_MOTIONS_DIR = \"/Users/ted/blenderkit_data/MotionBlendAI-1/project/seed_motions\"\n\ndef analyze_motion_name(filename: str) -> Dict[str, Any]:\n    \"\"\"\n    Analyze motion filename to extract semantic information.\n    \n    Args:\n        filename: Motion capture filename\n        \n    Returns:\n        Dictionary containing motion analysis\n    \"\"\"\n    name = os.path.splitext(filename)[0].lower()\n    \n    # Motion type classification\n    if any(word in name for word in ['dance', 'dancing', 'rain']):\n        category = 'dance'\n        motion_type = 'dance'\n        tags = ['dance', 'performance', 'artistic']\n        complexity = 0.8\n    elif any(word in name for word in ['punch', 'kick', 'fight', 'martial']):\n        category = 'combat'\n        motion_type = 'combat'\n        tags = ['martial-arts', 'combat', 'technique']\n        complexity = 0.7\n    elif any(word in name for word in ['tennis', 'sport', 'match']):\n        category = 'athletic'\n        motion_type = 'athletic'\n        tags = ['sports', 'athletic', 'professional']\n        complexity = 0.75\n    elif any(word in name for word in ['magic', 'spell', 'mage']):\n        category = 'performance'\n        motion_type = 'gesture'\n        tags = ['magic', 'fantasy', 'performance']\n        complexity = 0.6\n    elif any(word in name for word in ['angry', 'emotion']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['emotional', 'expression', 'dramatic']\n        complexity = 0.5\n    elif any(word in name for word in ['meta', 'animation']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['basic', 'template', 'generic']\n        complexity = 0.4\n    elif any(word in name for word in ['shoot', 'reaction']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['reaction', 'response', 'dramatic']\n        complexity = 0.6\n    else:\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['general', 'motion']\n        complexity = 0.5\n    \n    # Add specific tags based on filename content\n    if 'air' in name:\n        tags.append('airborne')\n    if 'mixamo' in name:\n        tags.append('mixamo')\n    if 'fist' in name:\n        tags.append('fist')\n    if 'slice' in name:\n        tags.append('slice')\n    if 'point' in name:\n        tags.append('point')\n    if 'variation' in name:\n        tags.append('variation')\n    \n    return {\n        'category': category,\n        'motion_type': motion_type,\n        'tags': list(set(tags)),  # Remove duplicates\n        'complexity': complexity\n    }\n\ndef generate_motion_vector(filename: str, analysis: Dict[str, Any]) -> List[float]:\n    \"\"\"\n    Generate realistic motion vector based on filename and analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        8-dimensional motion vector\n    \"\"\"\n    # Use filename hash for consistent but varied vectors\n    hash_obj = hashlib.md5(filename.encode())\n    hash_int = int(hash_obj.hexdigest()[:8], 16)\n    \n    # Base vector from hash\n    base_vector = [(hash_int >> (i * 4)) & 0xF for i in range(8)]\n    \n    # Normalize to 0-1 range\n    base_vector = [x / 15.0 for x in base_vector]\n    \n    # Adjust based on motion characteristics\n    complexity = analysis['complexity']\n    motion_type = analysis['motion_type']\n    \n    # Apply motion-type specific adjustments\n    if motion_type == 'athletic':\n        # Higher energy, more dynamic\n        base_vector = [min(1.0, x + 0.2) for x in base_vector]\n    elif motion_type == 'dance':\n        # Rhythmic patterns\n        for i in range(0, 8, 2):\n            base_vector[i] = min(1.0, base_vector[i] + 0.15)\n    elif motion_type == 'combat':\n        # Sharp, controlled movements\n        base_vector = [min(1.0, x + 0.1) if i % 2 == 0 else max(0.1, x - 0.1) \n                      for i, x in enumerate(base_vector)]\n    \n    # Apply complexity scaling\n    base_vector = [x * complexity + (1 - complexity) * 0.3 for x in base_vector]\n    \n    return [round(x, 3) for x in base_vector]\n\ndef estimate_motion_metadata(filename: str, analysis: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Estimate realistic motion metadata based on file analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        Motion metadata dictionary\n    \"\"\"\n    # File format\n    ext = os.path.splitext(filename)[1].lower()\n    format_map = {\n        '.fbx': 'FBX',\n        '.trc': 'TRC', \n        '.bvh': 'BVH',\n        '.glb': 'GLB',\n        '.npy': 'NPY'\n    }\n    \n    motion_format = format_map.get(ext, 'FBX')\n    \n    # Estimate parameters based on motion type\n    motion_type = analysis['motion_type']\n    complexity = analysis['complexity']\n    \n    if motion_type == 'dance':\n        frames = int(180 + complexity * 240)  # 180-420 frames\n        duration = frames / 30.0  # 30 FPS\n        joints = 30 + int(complexity * 5)  # 30-35 joints\n    elif motion_type == 'athletic':\n        frames = int(60 + complexity * 120)  # 60-180 frames\n        duration = frames / 30.0\n        joints = 25 + int(complexity * 7)  # 25-32 joints\n    elif motion_type == 'combat':\n        frames = int(45 + complexity * 90)   # 45-135 frames\n        duration = frames / 30.0\n        joints = 25 + int(complexity * 5)   # 25-30 joints\n    else:  # gesture\n        frames = int(30 + complexity * 150)  # 30-180 frames\n        duration = frames / 30.0\n        joints = 22 + int(complexity * 8)   # 22-30 joints\n    \n    return {\n        'frames': frames,\n        'joints': joints,\n        'duration': round(duration, 1),\n        'format': motion_format,\n        'category': analysis['category'],\n        'tags': analysis['tags'],\n        'fps': 30.0,\n        'file_size': int(frames * joints * 8)  # Estimated bytes\n    }\n\ndef generate_semantic_description(filename: str, analysis: Dict[str, Any]) -> str:\n    \"\"\"\n    Generate semantic description for motion based on analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        Semantic description string\n    \"\"\"\n    base_name = os.path.splitext(filename)[0].replace('_', ' ').replace('-', ' ')\n    motion_type = analysis['motion_type']\n    category = analysis['category']\n    tags = analysis['tags']\n    \n    # Base description templates\n    templates = {\n        'dance': f\"Dynamic {base_name} featuring rhythmic movement patterns with artistic expression\",\n        'athletic': f\"High-performance {base_name} demonstrating athletic skill and physical coordination\", \n        'combat': f\"Precise {base_name} showcasing martial arts technique and controlled power\",\n        'gesture': f\"Expressive {base_name} with clear communication and intentional movement\"\n    }\n    \n    description = templates.get(motion_type, f\"Motion capture sequence: {base_name}\")\n    \n    # Add contextual details based on tags\n    if 'mixamo' in tags:\n        description += \" from Mixamo animation library\"\n    if 'professional' in tags:\n        description += \" with professional-grade execution\"\n    if 'emotional' in tags:\n        description += \" conveying strong emotional content\"\n    if 'fantasy' in tags:\n        description += \" with fantasy and magical elements\"\n    \n    return description\n\ndef get_seed_motions() -> List[Dict[str, Any]]:\n    \"\"\"\n    Generate comprehensive mock data for all seed motions.\n    \n    Returns:\n        List of motion dictionaries with full metadata\n    \"\"\"\n    if not os.path.exists(SEED_MOTIONS_DIR):\n        print(f\"Warning: Seed motions directory not found: {SEED_MOTIONS_DIR}\")\n        return []\n    \n    motions = []\n    \n    # Get all motion files\n    motion_files = []\n    for file in os.listdir(SEED_MOTIONS_DIR):\n        if file.lower().endswith(('.fbx', '.trc', '.bvh', '.glb', '.npy')):\n            motion_files.append(file)\n    \n    # Sort for consistent ordering\n    motion_files.sort()\n    \n    for i, filename in enumerate(motion_files, 1):\n        # Analyze motion\n        analysis = analyze_motion_name(filename)\n        metadata = estimate_motion_metadata(filename, analysis)\n        vector = generate_motion_vector(filename, analysis)\n        description = generate_semantic_description(filename, analysis)\n        \n        # Create motion dictionary\n        motion = {\n            'id': f'seed_motion_{i:03d}',\n            'name': os.path.splitext(filename)[0].replace('_', ' ').title(),\n            'description': description,\n            'motion_vector': vector,\n            'metadata': metadata,\n            'motion_type': analysis['motion_type'],\n            'quality_score': round(0.7 + analysis['complexity'] * 0.25, 2),\n            'complexity': analysis['complexity'],\n            'blend_compatibility': 'high' if analysis['complexity'] > 0.6 else 'medium',\n            'file_path': os.path.join(SEED_MOTIONS_DIR, filename),\n            'checksum': hashlib.md5(filename.encode()).hexdigest()[:16],\n            'created_at': f\"2025-10-09T{10 + (i * 2) % 12:02d}:{(i * 5) % 60:02d}:00Z\",\n            'updated_at': time.strftime('%Y-%m-%dT%H:%M:%SZ')\n        }\n        \n        motions.append(motion)\n    \n    return motions\n\ndef get_motion_categories() -> Dict[str, List[str]]:\n    \"\"\"\n    Get categorized list of seed motions.\n    \n    Returns:\n        Dictionary mapping categories to motion IDs\n    \"\"\"\n    motions = get_seed_motions()\n    categories = {}\n    \n    for motion in motions:\n        category = motion['metadata']['category']\n        if category not in categories:\n            categories[category] = []\n        categories[category].append(motion['id'])\n    \n    return categories\n\ndef find_motions_by_tag(tag: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Find seed motions containing a specific tag.\n    \n    Args:\n        tag: Tag to search for\n        \n    Returns:\n        List of matching motions\n    \"\"\"\n    motions = get_seed_motions()\n    return [m for m in motions if tag.lower() in [t.lower() for t in m['metadata']['tags']]]\n\ndef get_motion_statistics() -> Dict[str, Any]:\n    \"\"\"\n    Get comprehensive statistics about seed motions.\n    \n    Returns:\n        Statistics dictionary\n    \"\"\"\n    motions = get_seed_motions()\n    \n    if not motions:\n        return {'total': 0, 'error': 'No motions found'}\n    \n    # Calculate statistics\n    categories = {}\n    formats = {}\n    total_duration = 0\n    total_frames = 0\n    complexity_scores = []\n    \n    for motion in motions:\n        # Categories\n        cat = motion['metadata']['category']\n        categories[cat] = categories.get(cat, 0) + 1\n        \n        # Formats\n        fmt = motion['metadata']['format']\n        formats[fmt] = formats.get(fmt, 0) + 1\n        \n        # Totals\n        total_duration += motion['metadata']['duration']\n        total_frames += motion['metadata']['frames']\n        complexity_scores.append(motion['complexity'])\n    \n    return {\n        'total_motions': len(motions),\n        'categories': categories,\n        'formats': formats,\n        'total_duration_seconds': round(total_duration, 1),\n        'total_frames': total_frames,\n        'average_complexity': round(sum(complexity_scores) / len(complexity_scores), 2),\n        'complexity_range': [min(complexity_scores), max(complexity_scores)],\n        'most_common_category': max(categories.items(), key=lambda x: x[1])[0],\n        'most_common_format': max(formats.items(), key=lambda x: x[1])[0]\n    }\n\nif __name__ == '__main__':\n    # Demo the seed motions system\n    print(\"🎭 MotionBlendAI Seed Motions Mock System\")\n    print(\"=\" * 50)\n    \n    motions = get_seed_motions()\n    print(f\"\\n📊 Generated {len(motions)} seed motions\")\n    \n    # Show statistics\n    stats = get_motion_statistics()\n    print(f\"\\n📈 Statistics:\")\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # Show sample motions\n    print(f\"\\n🎬 Sample Motions:\")\n    for motion in motions[:3]:\n        print(f\"  • {motion['name']} ({motion['metadata']['category']})\")\n        print(f\"    Duration: {motion['metadata']['duration']}s, Complexity: {motion['complexity']}\")\n    \n    # Show categories\n    categories = get_motion_categories()\n    print(f\"\\n📁 Categories:\")\n    for cat, motion_ids in categories.items():\n        print(f\"  {cat}: {len(motion_ids)} motions\")\n
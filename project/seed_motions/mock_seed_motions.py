#!/usr/bin/env python3\n\"\"\"\nSeed Motions Mock Implementation\n===============================\n\nThis module provides comprehensive mock motion data generation and management\nfor the MotionBlendAI seed_motions directory. It creates realistic motion\ncapture data that mirrors the actual FBX, TRC, BVH, and GLB files found\nin the seed_motions folder.\n\nFeatures:\n---------\n‚Ä¢ Realistic motion metadata extraction from actual files\n‚Ä¢ Mock vector generation based on motion characteristics  \n‚Ä¢ Comprehensive categorization and tagging system\n‚Ä¢ Integration with Elasticsearch indexing pipeline\n‚Ä¢ Support for all major motion capture formats\n‚Ä¢ Semantic field generation for enhanced search\n\nUsage:\n------\n    from project.seed_motions.mock_seed_motions import get_seed_motions, index_seed_motions\n    \n    # Get all mock seed motions\n    motions = get_seed_motions()\n    \n    # Index to Elasticsearch\n    index_seed_motions(elasticsearch_client)\n\nAuthor: MotionBlendAI Team\nVersion: 1.0.0\n\"\"\"\n\nimport os\nimport time\nimport hashlib\nfrom typing import Dict, List, Any, Optional\nimport re\n\n# Seed motions directory path\nSEED_MOTIONS_DIR = \"/Users/ted/blenderkit_data/MotionBlendAI-1/project/seed_motions\"\n\ndef analyze_motion_name(filename: str) -> Dict[str, Any]:\n    \"\"\"\n    Analyze motion filename to extract semantic information.\n    \n    Args:\n        filename: Motion capture filename\n        \n    Returns:\n        Dictionary containing motion analysis\n    \"\"\"\n    name = os.path.splitext(filename)[0].lower()\n    \n    # Motion type classification\n    if any(word in name for word in ['dance', 'dancing', 'rain']):\n        category = 'dance'\n        motion_type = 'dance'\n        tags = ['dance', 'performance', 'artistic']\n        complexity = 0.8\n    elif any(word in name for word in ['punch', 'kick', 'fight', 'martial']):\n        category = 'combat'\n        motion_type = 'combat'\n        tags = ['martial-arts', 'combat', 'technique']\n        complexity = 0.7\n    elif any(word in name for word in ['tennis', 'sport', 'match']):\n        category = 'athletic'\n        motion_type = 'athletic'\n        tags = ['sports', 'athletic', 'professional']\n        complexity = 0.75\n    elif any(word in name for word in ['magic', 'spell', 'mage']):\n        category = 'performance'\n        motion_type = 'gesture'\n        tags = ['magic', 'fantasy', 'performance']\n        complexity = 0.6\n    elif any(word in name for word in ['angry', 'emotion']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['emotional', 'expression', 'dramatic']\n        complexity = 0.5\n    elif any(word in name for word in ['meta', 'animation']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['basic', 'template', 'generic']\n        complexity = 0.4\n    elif any(word in name for word in ['shoot', 'reaction']):\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['reaction', 'response', 'dramatic']\n        complexity = 0.6\n    else:\n        category = 'gesture'\n        motion_type = 'gesture'\n        tags = ['general', 'motion']\n        complexity = 0.5\n    \n    # Add specific tags based on filename content\n    if 'air' in name:\n        tags.append('airborne')\n    if 'mixamo' in name:\n        tags.append('mixamo')\n    if 'fist' in name:\n        tags.append('fist')\n    if 'slice' in name:\n        tags.append('slice')\n    if 'point' in name:\n        tags.append('point')\n    if 'variation' in name:\n        tags.append('variation')\n    \n    return {\n        'category': category,\n        'motion_type': motion_type,\n        'tags': list(set(tags)),  # Remove duplicates\n        'complexity': complexity\n    }\n\ndef generate_motion_vector(filename: str, analysis: Dict[str, Any]) -> List[float]:\n    \"\"\"\n    Generate realistic motion vector based on filename and analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        8-dimensional motion vector\n    \"\"\"\n    # Use filename hash for consistent but varied vectors\n    hash_obj = hashlib.md5(filename.encode())\n    hash_int = int(hash_obj.hexdigest()[:8], 16)\n    \n    # Base vector from hash\n    base_vector = [(hash_int >> (i * 4)) & 0xF for i in range(8)]\n    \n    # Normalize to 0-1 range\n    base_vector = [x / 15.0 for x in base_vector]\n    \n    # Adjust based on motion characteristics\n    complexity = analysis['complexity']\n    motion_type = analysis['motion_type']\n    \n    # Apply motion-type specific adjustments\n    if motion_type == 'athletic':\n        # Higher energy, more dynamic\n        base_vector = [min(1.0, x + 0.2) for x in base_vector]\n    elif motion_type == 'dance':\n        # Rhythmic patterns\n        for i in range(0, 8, 2):\n            base_vector[i] = min(1.0, base_vector[i] + 0.15)\n    elif motion_type == 'combat':\n        # Sharp, controlled movements\n        base_vector = [min(1.0, x + 0.1) if i % 2 == 0 else max(0.1, x - 0.1) \n                      for i, x in enumerate(base_vector)]\n    \n    # Apply complexity scaling\n    base_vector = [x * complexity + (1 - complexity) * 0.3 for x in base_vector]\n    \n    return [round(x, 3) for x in base_vector]\n\ndef estimate_motion_metadata(filename: str, analysis: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Estimate realistic motion metadata based on file analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        Motion metadata dictionary\n    \"\"\"\n    # File format\n    ext = os.path.splitext(filename)[1].lower()\n    format_map = {\n        '.fbx': 'FBX',\n        '.trc': 'TRC', \n        '.bvh': 'BVH',\n        '.glb': 'GLB',\n        '.npy': 'NPY'\n    }\n    \n    motion_format = format_map.get(ext, 'FBX')\n    \n    # Estimate parameters based on motion type\n    motion_type = analysis['motion_type']\n    complexity = analysis['complexity']\n    \n    if motion_type == 'dance':\n        frames = int(180 + complexity * 240)  # 180-420 frames\n        duration = frames / 30.0  # 30 FPS\n        joints = 30 + int(complexity * 5)  # 30-35 joints\n    elif motion_type == 'athletic':\n        frames = int(60 + complexity * 120)  # 60-180 frames\n        duration = frames / 30.0\n        joints = 25 + int(complexity * 7)  # 25-32 joints\n    elif motion_type == 'combat':\n        frames = int(45 + complexity * 90)   # 45-135 frames\n        duration = frames / 30.0\n        joints = 25 + int(complexity * 5)   # 25-30 joints\n    else:  # gesture\n        frames = int(30 + complexity * 150)  # 30-180 frames\n        duration = frames / 30.0\n        joints = 22 + int(complexity * 8)   # 22-30 joints\n    \n    return {\n        'frames': frames,\n        'joints': joints,\n        'duration': round(duration, 1),\n        'format': motion_format,\n        'category': analysis['category'],\n        'tags': analysis['tags'],\n        'fps': 30.0,\n        'file_size': int(frames * joints * 8)  # Estimated bytes\n    }\n\ndef generate_semantic_description(filename: str, analysis: Dict[str, Any]) -> str:\n    \"\"\"\n    Generate semantic description for motion based on analysis.\n    \n    Args:\n        filename: Motion filename\n        analysis: Motion analysis data\n        \n    Returns:\n        Semantic description string\n    \"\"\"\n    base_name = os.path.splitext(filename)[0].replace('_', ' ').replace('-', ' ')\n    motion_type = analysis['motion_type']\n    category = analysis['category']\n    tags = analysis['tags']\n    \n    # Base description templates\n    templates = {\n        'dance': f\"Dynamic {base_name} featuring rhythmic movement patterns with artistic expression\",\n        'athletic': f\"High-performance {base_name} demonstrating athletic skill and physical coordination\", \n        'combat': f\"Precise {base_name} showcasing martial arts technique and controlled power\",\n        'gesture': f\"Expressive {base_name} with clear communication and intentional movement\"\n    }\n    \n    description = templates.get(motion_type, f\"Motion capture sequence: {base_name}\")\n    \n    # Add contextual details based on tags\n    if 'mixamo' in tags:\n        description += \" from Mixamo animation library\"\n    if 'professional' in tags:\n        description += \" with professional-grade execution\"\n    if 'emotional' in tags:\n        description += \" conveying strong emotional content\"\n    if 'fantasy' in tags:\n        description += \" with fantasy and magical elements\"\n    \n    return description\n\ndef get_seed_motions() -> List[Dict[str, Any]]:\n    \"\"\"\n    Generate comprehensive mock data for all seed motions.\n    \n    Returns:\n        List of motion dictionaries with full metadata\n    \"\"\"\n    if not os.path.exists(SEED_MOTIONS_DIR):\n        print(f\"Warning: Seed motions directory not found: {SEED_MOTIONS_DIR}\")\n        return []\n    \n    motions = []\n    \n    # Get all motion files\n    motion_files = []\n    for file in os.listdir(SEED_MOTIONS_DIR):\n        if file.lower().endswith(('.fbx', '.trc', '.bvh', '.glb', '.npy')):\n            motion_files.append(file)\n    \n    # Sort for consistent ordering\n    motion_files.sort()\n    \n    for i, filename in enumerate(motion_files, 1):\n        # Analyze motion\n        analysis = analyze_motion_name(filename)\n        metadata = estimate_motion_metadata(filename, analysis)\n        vector = generate_motion_vector(filename, analysis)\n        description = generate_semantic_description(filename, analysis)\n        \n        # Create motion dictionary\n        motion = {\n            'id': f'seed_motion_{i:03d}',\n            'name': os.path.splitext(filename)[0].replace('_', ' ').title(),\n            'description': description,\n            'motion_vector': vector,\n            'metadata': metadata,\n            'motion_type': analysis['motion_type'],\n            'quality_score': round(0.7 + analysis['complexity'] * 0.25, 2),\n            'complexity': analysis['complexity'],\n            'blend_compatibility': 'high' if analysis['complexity'] > 0.6 else 'medium',\n            'file_path': os.path.join(SEED_MOTIONS_DIR, filename),\n            'checksum': hashlib.md5(filename.encode()).hexdigest()[:16],\n            'created_at': f\"2025-10-09T{10 + (i * 2) % 12:02d}:{(i * 5) % 60:02d}:00Z\",\n            'updated_at': time.strftime('%Y-%m-%dT%H:%M:%SZ')\n        }\n        \n        motions.append(motion)\n    \n    return motions\n\ndef get_motion_categories() -> Dict[str, List[str]]:\n    \"\"\"\n    Get categorized list of seed motions.\n    \n    Returns:\n        Dictionary mapping categories to motion IDs\n    \"\"\"\n    motions = get_seed_motions()\n    categories = {}\n    \n    for motion in motions:\n        category = motion['metadata']['category']\n        if category not in categories:\n            categories[category] = []\n        categories[category].append(motion['id'])\n    \n    return categories\n\ndef find_motions_by_tag(tag: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Find seed motions containing a specific tag.\n    \n    Args:\n        tag: Tag to search for\n        \n    Returns:\n        List of matching motions\n    \"\"\"\n    motions = get_seed_motions()\n    return [m for m in motions if tag.lower() in [t.lower() for t in m['metadata']['tags']]]\n\ndef get_motion_statistics() -> Dict[str, Any]:\n    \"\"\"\n    Get comprehensive statistics about seed motions.\n    \n    Returns:\n        Statistics dictionary\n    \"\"\"\n    motions = get_seed_motions()\n    \n    if not motions:\n        return {'total': 0, 'error': 'No motions found'}\n    \n    # Calculate statistics\n    categories = {}\n    formats = {}\n    total_duration = 0\n    total_frames = 0\n    complexity_scores = []\n    \n    for motion in motions:\n        # Categories\n        cat = motion['metadata']['category']\n        categories[cat] = categories.get(cat, 0) + 1\n        \n        # Formats\n        fmt = motion['metadata']['format']\n        formats[fmt] = formats.get(fmt, 0) + 1\n        \n        # Totals\n        total_duration += motion['metadata']['duration']\n        total_frames += motion['metadata']['frames']\n        complexity_scores.append(motion['complexity'])\n    \n    return {\n        'total_motions': len(motions),\n        'categories': categories,\n        'formats': formats,\n        'total_duration_seconds': round(total_duration, 1),\n        'total_frames': total_frames,\n        'average_complexity': round(sum(complexity_scores) / len(complexity_scores), 2),\n        'complexity_range': [min(complexity_scores), max(complexity_scores)],\n        'most_common_category': max(categories.items(), key=lambda x: x[1])[0],\n        'most_common_format': max(formats.items(), key=lambda x: x[1])[0]\n    }\n\nif __name__ == '__main__':\n    # Demo the seed motions system\n    print(\"üé≠ MotionBlendAI Seed Motions Mock System\")\n    print(\"=\" * 50)\n    \n    motions = get_seed_motions()\n    print(f\"\\nüìä Generated {len(motions)} seed motions\")\n    \n    # Show statistics\n    stats = get_motion_statistics()\n    print(f\"\\nüìà Statistics:\")\n    for key, value in stats.items():\n        print(f\"  {key}: {value}\")\n    \n    # Show sample motions\n    print(f\"\\nüé¨ Sample Motions:\")\n    for motion in motions[:3]:\n        print(f\"  ‚Ä¢ {motion['name']} ({motion['metadata']['category']})\")\n        print(f\"    Duration: {motion['metadata']['duration']}s, Complexity: {motion['complexity']}\")\n    \n    # Show categories\n    categories = get_motion_categories()\n    print(f\"\\nüìÅ Categories:\")\n    for cat, motion_ids in categories.items():\n        print(f\"  {cat}: {len(motion_ids)} motions\")\n